rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Rules for admin configuration
    match /admin_config/main_credentials {
      allow read: if true; 
      allow write: if request.auth != null; 
    }
    
    // Enhanced rules for contactSubmissions (User Onboarding & Application Data)
    match /contactSubmissions/{submissionId} {
      // Allow anyone to read all submissions (for admin dashboard)
      allow read: if true; 
      
      // Allow anyone to create new submissions (for application forms)
      allow create: if true; 
      
      // Allow updates only for specific scenarios
      allow update: if isValidOnboardingUpdate(resource, request) || 
                       isAdminStatusUpdate(resource, request) ||
                       isAdminCredentialAssignment(resource, request);
    }
    
    // Helper functions for contactSubmissions rules
    
    // Validates onboarding updates by accepted users
    function isValidOnboardingUpdate(existingData, incomingRequest) {
      let existingDoc = existingData.data;
      let incomingDoc = incomingRequest.resource.data;
      
      return existingDoc.status == 'accepted' &&
             // Core immutable fields must remain unchanged
             isImmutableFieldsUnchanged(existingDoc, incomingDoc) &&
             // Only onboarding fields can be modified
             isOnboardingFieldsOnly(existingDoc, incomingDoc) &&
             // Validate the data being updated
             isValidOnboardingData(incomingDoc) &&
             // Ensure logical progression (can't mark steps complete without data)
             isValidOnboardingProgression(existingDoc, incomingDoc);
    }
    
    // Ensures core application data cannot be modified during onboarding
    function isImmutableFieldsUnchanged(existingDoc, incomingDoc) {
      let immutableFields = ['email', 'status', 'submittedAt', 'campusStatus', 'companyName', 'idea'];
      
      return immutableFields.all(field, 
        !existingDoc.keys().hasAny([field]) || 
        !incomingDoc.keys().hasAny([field]) || 
        existingDoc[field] == incomingDoc[field]
      );
    }
    
    // Defines which fields can be updated during onboarding
    function isOnboardingFieldsOnly(existingDoc, incomingDoc) {
      let allowedOnboardingFields = [
        // Core fields (read-only during onboarding)
        'name', 'email', 'status', 'submittedAt', 'campusStatus', 'companyName', 'idea',
        // Password fields
        'temporaryUserId', 'temporaryPassword', 'passwordUpdatedAt',
        // Profile fields
        'firstName', 'lastName', 'phone', 'bio', 'linkedin', 'profileUpdatedAt',
        // Notification fields
        'notificationPreferences',
        // Onboarding tracking
        'onboardingProgress', 'onboardingCompleted', 'onboardingCompletedAt'
      ];
      
      return incomingDoc.keys().hasOnly(allowedOnboardingFields);
    }
    
    // Validates the actual data being updated
    function isValidOnboardingData(incomingDoc) {
      return isValidPasswordUpdate(incomingDoc) &&
             isValidProfileUpdate(incomingDoc) &&
             isValidNotificationUpdate(incomingDoc) &&
             isValidOnboardingProgressUpdate(incomingDoc);
    }
    
    // Validates password changes
    function isValidPasswordUpdate(incomingDoc) {
      return !incomingDoc.keys().hasAny(['temporaryPassword']) ||
             (incomingDoc.temporaryPassword is string && 
              incomingDoc.temporaryPassword.size() >= 6 &&
              incomingDoc.temporaryPassword.size() <= 128);
    }
    
    // Validates profile information
    function isValidProfileUpdate(incomingDoc) {
      let firstNameValid = !incomingDoc.keys().hasAny(['firstName']) ||
                          (incomingDoc.firstName is string && 
                           incomingDoc.firstName.size() > 0 &&
                           incomingDoc.firstName.size() <= 50);
      
      let lastNameValid = !incomingDoc.keys().hasAny(['lastName']) ||
                         (incomingDoc.lastName is string && 
                          incomingDoc.lastName.size() > 0 &&
                          incomingDoc.lastName.size() <= 50);
      
      let phoneValid = !incomingDoc.keys().hasAny(['phone']) ||
                      incomingDoc.phone == '' ||
                      (incomingDoc.phone is string && 
                       incomingDoc.phone.size() >= 10 &&
                       incomingDoc.phone.size() <= 15);
      
      let bioValid = !incomingDoc.keys().hasAny(['bio']) ||
                    incomingDoc.bio == '' ||
                    (incomingDoc.bio is string && 
                     incomingDoc.bio.size() <= 500);
      
      let linkedinValid = !incomingDoc.keys().hasAny(['linkedin']) ||
                         incomingDoc.linkedin == '' ||
                         (incomingDoc.linkedin is string &&
                          (incomingDoc.linkedin.matches('https://.*linkedin.com/.*') ||
                           incomingDoc.linkedin.matches('https://.*linkedin.com/in/.*')));
      
      // If name is being updated, ensure it matches firstName + lastName
      let nameValid = !incomingDoc.keys().hasAny(['name', 'firstName', 'lastName']) ||
                     !incomingDoc.keys().hasAll(['name', 'firstName', 'lastName']) ||
                     incomingDoc.name == (incomingDoc.firstName + ' ' + incomingDoc.lastName);
      
      return firstNameValid && lastNameValid && phoneValid && bioValid && linkedinValid && nameValid;
    }
    
    // Validates notification preferences
    function isValidNotificationUpdate(incomingDoc) {
      return !incomingDoc.keys().hasAny(['notificationPreferences']) ||
             (incomingDoc.notificationPreferences is map &&
              incomingDoc.notificationPreferences.keys().hasAll(['emailNotifications']) &&
              incomingDoc.notificationPreferences.emailNotifications is bool);
    }
    
    // Validates onboarding progress tracking
    function isValidOnboardingProgressUpdate(incomingDoc) {
      let progressValid = !incomingDoc.keys().hasAny(['onboardingProgress']) ||
                         (incomingDoc.onboardingProgress is map);
      
      let completedValid = !incomingDoc.keys().hasAny(['onboardingCompleted']) ||
                          incomingDoc.onboardingCompleted is bool;
      
      return progressValid && completedValid;
    }
    
    // Ensures logical progression of onboarding steps
    function isValidOnboardingProgression(existingDoc, incomingDoc) {
      // If marking password as changed, password must be updated
      let passwordProgressValid = 
        !incomingDoc.keys().hasAny(['onboardingProgress']) ||
        !incomingDoc.onboardingProgress.keys().hasAny(['passwordChanged']) ||
        !incomingDoc.onboardingProgress.passwordChanged ||
        incomingDoc.keys().hasAny(['temporaryPassword', 'passwordUpdatedAt']);
      
      // If marking profile as completed, profile fields must be present
      let profileProgressValid = 
        !incomingDoc.keys().hasAny(['onboardingProgress']) ||
        !incomingDoc.onboardingProgress.keys().hasAny(['profileCompleted']) ||
        !incomingDoc.onboardingProgress.profileCompleted ||
        (incomingDoc.keys().hasAny(['firstName', 'lastName']) &&
         incomingDoc.firstName is string && incomingDoc.firstName.size() > 0 &&
         incomingDoc.lastName is string && incomingDoc.lastName.size() > 0);
      
      // If marking notifications as configured, preferences must be set
      let notificationProgressValid = 
        !incomingDoc.keys().hasAny(['onboardingProgress']) ||
        !incomingDoc.onboardingProgress.keys().hasAny(['notificationsConfigured']) ||
        !incomingDoc.onboardingProgress.notificationsConfigured ||
        incomingDoc.keys().hasAny(['notificationPreferences']);
      
      return passwordProgressValid && profileProgressValid && notificationProgressValid;
    }
    
    // Admin operations for application status updates
    function isAdminStatusUpdate(existingData, incomingRequest) {
      let existingDoc = existingData.data;
      let incomingDoc = incomingRequest.resource.data;
      
      // Only allow status changes from 'pending' to 'accepted' or 'rejected'
      return existingDoc.status == 'pending' &&
             (incomingDoc.status == 'accepted' || incomingDoc.status == 'rejected') &&
             incomingDoc.keys().hasAny(['processedByAdminAt']) &&
             // Ensure other critical fields remain unchanged
             incomingDoc.email == existingDoc.email &&
             incomingDoc.submittedAt == existingDoc.submittedAt;
    }
    
    // Admin operations for credential assignment after acceptance
    function isAdminCredentialAssignment(existingData, incomingRequest) {
      let existingDoc = existingData.data;
      let incomingDoc = incomingRequest.resource.data;
      
      return existingDoc.status == 'accepted' &&
             incomingDoc.status == 'accepted' &&
             incomingDoc.keys().hasAll(['temporaryUserId', 'temporaryPassword']) &&
             incomingDoc.temporaryUserId is string &&
             incomingDoc.temporaryUserId.size() > 0 &&
             incomingDoc.temporaryPassword is string &&
             incomingDoc.temporaryPassword.size() >= 6;
    }
    
    // Rules for events
    match /events/{eventId} {
      allow read: if true;
      allow create: if true;  // WARNING: DEVELOPMENT ONLY
      allow update: if true;  // WARNING: DEVELOPMENT ONLY
      allow delete: if true;  // WARNING: DEVELOPMENT ONLY
    }
    
    // Rules for mentors
    match /mentors/{mentorId} {
      allow read: if true;
      allow create: if true;  // WARNING: DEVELOPMENT ONLY
      allow update: if true;  // WARNING: DEVELOPMENT ONLY
      allow delete: if true;  // WARNING: DEVELOPMENT ONLY
    }
    
    // Rules for startups
    match /startups/{startupId} {
      allow read: if true;
      allow create: if true;  // WARNING: DEVELOPMENT ONLY
      allow update: if true;  // WARNING: DEVELOPMENT ONLY
      allow delete: if true;  // WARNING: DEVELOPMENT ONLY
    }
  }
}
      // Validate password requirements
      let passwordValid = !incomingDoc.keys().hasAny(['temporaryPassword']) ||
                         (incomingDoc.temporaryPassword is string && 
                          incomingDoc.temporaryPassword.size() >= 6);
      
      // Validate profile requirements
      let profileValid = !incomingDoc.keys().hasAny(['firstName', 'lastName']) ||
                        (incomingDoc.firstName is string && 
                         incomingDoc.firstName.size() > 0 &&
                         incomingDoc.lastName is string && 
                         incomingDoc.lastName.size() > 0);
      
      // Validate LinkedIn URL format (if provided)
      let linkedinValid = !incomingDoc.keys().hasAny(['linkedin']) ||
                         incomingDoc.linkedin == '' ||
                         incomingDoc.linkedin.matches('https://.*linkedin.com/.*') ||
                         incomingDoc.linkedin.matches('https://.*linkedin.com/in/.*');
      
      // Validate notification preferences structure
      let notificationValid = !incomingDoc.keys().hasAny(['notificationPreferences']) ||
                             (incomingDoc.notificationPreferences.keys().hasAll(['emailNotifications']) &&
                              incomingDoc.notificationPreferences.emailNotifications is bool);
      
      return passwordValid && profileValid && linkedinValid && notificationValid;
    }
    
    function isAdminUpdate(incomingRequest) {
      // Allow admin operations for application processing
      // This covers accept/reject operations and credential assignment
      let isStatusUpdate = incomingRequest.resource.data.keys().hasAny([
        'status', 'processedByAdminAt'
      ]);
      
      let isCredentialAssignment = incomingRequest.resource.data.keys().hasAny([
        'temporaryUserId', 'temporaryPassword'
      ]) && incomingRequest.resource.data.status == 'accepted';
      
      return isStatusUpdate || isCredentialAssignment;
    }

    // Rules for events
    match /events/{eventId} {
      allow read: if true;    // Allows anyone to read events for the public page
      allow create: if true;  // WARNING: DEVELOPMENT ONLY - Allows anyone to create events.
                              // Secure this for production (e.g., if request.auth.token.isAdmin == true;)
      allow update: if true; // Placeholder: No one can update events yet
      allow delete: if true; // Placeholder: No one can delete events yet
    }
    
    match /mentors/{mentorId} {
      allow read: if true; // Allows anyone to read mentors for the public page
      allow create: if true; 
      allow update: if true; // Placeholder: No one can update events yet
      allow delete: if true;
      // EXAMPLE: Allow anyone to write for dev. MUST be restricted to admin.
      // update, delete will be needed later
    }
    
     // Rules for startups
    match /startups/{startupId} {
      allow read: if true; // Allows anyone to read startups for the public page
      allow create: if true; // WARNING: DEVELOPMENT ONLY. Allows anyone to create.
                                            // In production, ensure your backend action is admin-only,
                                            // or if admin uses Firebase Auth: if request.auth.token.isAdmin == true;
      allow update: if true; // WARNING: DEVELOPMENT ONLY. Allows anyone to update.
                                             // In production, ensure your backend action is admin-only.
                                             // Or, if admin uses Firebase Auth: if request.auth.token.isAdmin == true;
      allow delete: if true; // WARNING: DEVELOPMENT ONLY. Allows anyone to delete.
                                             // In production, ensure your backend action is admin-only.
                                             // Or, if admin uses Firebase Auth: if request.auth.token.isAdmin == true;
    }
    
    // Add other rules for other collections if needed
  }
}
